"""Schema builder utilities for creating Pydantic models from JSON schemas."""

from pydantic import BaseModel, create_model, Field
from typing import Any, Dict, List, Type, Optional
from datetime import date, datetime


def create_pydantic_model_from_json_schema(
    json_schema: Dict[str, Any], 
    field_options: Dict[str, List[str]] = None,
    model_name: str = "DynamicModel"
) -> Type[BaseModel]:
    """Create a Pydantic model from JSON schema with field options and widget configurations.
    
    This function handles the conversion from JSON schema (as generated by model_json_schema())
    back to a Pydantic model, properly reconstructing Optional types from anyOf patterns.
    
    Args:
        json_schema: A dictionary representing the JSON schema
        field_options: Dictionary mapping field names to available options for widgets
        model_name: Name for the dynamically created model
        
    Returns:
        A dynamically created Pydantic model class
    """
    if field_options is None:
        field_options = {}
        
    fields = {}

    for field_name, field_schema in json_schema.get("properties", {}).items():
        # Check for anyOf pattern (used for optional fields)
        if "anyOf" in field_schema:
            # Extract the actual type from anyOf
            any_of_types = field_schema["anyOf"]
            # Find the non-null type
            actual_type_schema = None
            for type_def in any_of_types:
                if type_def.get("type") != "null":
                    actual_type_schema = type_def
                    break
            
            if actual_type_schema:
                field_type = actual_type_schema.get("type")
                field_format = actual_type_schema.get("format")
                
                # Determine Python type
                if field_type == "string":
                    if field_format == "date":
                        base_type = date
                    elif field_format == "datetime":
                        base_type = datetime
                    else:
                        base_type = str
                elif field_type == "integer":
                    base_type = int
                elif field_type == "number":
                    base_type = float
                elif field_type == "boolean":
                    base_type = bool
                elif field_type == "array":
                    # For arrays, check if we have options (for multiselect)
                    if field_name in field_options:
                        # Use List[str] for multiselect with options
                        base_type = List[str]
                    else:
                        items_schema = actual_type_schema.get("items", {})
                        items_type = create_pydantic_model_from_json_schema(items_schema, field_options, f"{model_name}Item")
                        base_type = List[items_type]
                elif field_type == "object":
                    base_type = create_pydantic_model_from_json_schema(actual_type_schema, field_options, f"{model_name}{field_name.capitalize()}")
                else:
                    base_type = Any
                
                # Make it optional since it has anyOf with null
                python_type = Optional[base_type]
            else:
                # Fallback if we can't determine type
                python_type = Any
        else:
            # Regular field without anyOf
            field_type = field_schema.get("type")
            field_format = field_schema.get("format")
            
            # Determine Python type
            if field_type == "string":
                if field_format == "date":
                    python_type = date
                elif field_format == "datetime":
                    python_type = datetime
                else:
                    python_type = str
            elif field_type == "integer":
                python_type = int
            elif field_type == "number":
                python_type = float
            elif field_type == "boolean":
                python_type = bool
            elif field_type == "array":
                # For arrays, check if we have options (for multiselect)
                if field_name in field_options:
                    # Use List[str] for multiselect with options
                    python_type = List[str]
                else:
                    items_type = create_pydantic_model_from_json_schema(field_schema.get("items", {}), field_options, f"{model_name}Item")
                    python_type = List[items_type]
            elif field_type == "object":
                python_type = create_pydantic_model_from_json_schema(field_schema, field_options, f"{model_name}{field_name.capitalize()}")
            else:
                python_type = Any

        is_required = field_name in json_schema.get("required", [])
        
        # Extract widget configuration directly from schema properties
        widget = field_schema.get("widget")
        kw = field_schema.get("kw", {}).copy()
        default_value = field_schema.get("default")
        
        # Handle options from different sources
        # 1. Check if options are directly in json_schema_extra
        if "options" in field_schema:
            kw["options"] = field_schema["options"]
        # 2. Add field_options if available and not already present
        elif field_name in field_options and "options" not in kw:
            kw["options"] = field_options[field_name]
        
        # Create Field with proper configuration
        if widget or kw or default_value is not None:
            # Build json_schema_extra
            json_schema_extra = {}
            if widget:
                json_schema_extra["widget"] = widget
            if kw:
                json_schema_extra["kw"] = kw

            field_info = Field(
                default=default_value,
                json_schema_extra=json_schema_extra
            )
            fields[field_name] = (python_type, field_info)
        else:
            # Regular field without widget configuration
            default = ... if is_required else None
            fields[field_name] = (python_type, default)

    return create_model(model_name, **fields)